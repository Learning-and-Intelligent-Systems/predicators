"""Learn operators by searching over sets of add effect sets."""

import abc
import functools
from dataclasses import dataclass
from typing import Callable, Dict, Iterator, List, Set, Tuple

from predicators import utils
from predicators.nsrt_learning.strips_learning import BaseSTRIPSLearner
from predicators.settings import CFG
from predicators.structs import LiftedAtom, LowLevelTrajectory, OptionSpec, \
    ParameterizedOption, PartialNSRTAndDatastore, Predicate, Segment, \
    STRIPSOperator


@dataclass(frozen=True)
class _EffectSets:
    # Maps a parameterized option to a set of option specs (for that option)
    # and add effects.
    _param_option_to_groups: Dict[ParameterizedOption,
                                  List[Tuple[OptionSpec, Set[LiftedAtom]]]]

    @functools.cached_property
    def _hash(self) -> int:
        option_to_hashable_group = {
            o: (tuple(v), frozenset(a))
            for o in self._param_option_to_groups
            for ((_, v), a) in self._param_option_to_groups[o]
        }
        return hash(tuple(option_to_hashable_group))

    def __hash__(self) -> int:
        return self._hash

    def __iter__(self) -> Iterator[Tuple[OptionSpec, Set[LiftedAtom]]]:
        for o in sorted(self._param_option_to_groups):
            for (spec, atoms) in self._param_option_to_groups[o]:
                yield (spec, atoms)


class _EffectSearchOperator(abc.ABC):
    """An operator that proposes successor sets of effect sets."""

    def __init__(
        self, trajectories: List[LowLevelTrajectory],
        predicates: Set[Predicate],
        effect_sets_to_operators: Callable[[_EffectSets], Set[STRIPSOperator]]
    ) -> None:
        self._trajectories = trajectories
        self._predicates = predicates
        self._effect_sets_to_operators = effect_sets_to_operators

    @abc.abstractmethod
    def get_successors(self,
                       effect_sets: _EffectSets) -> Iterator[_EffectSets]:
        """Generate zero or more successor effect sets."""
        raise NotImplementedError("Override me!")


class _BackChainingEffectSearchOperator(_EffectSearchOperator):
    """An operator that uses backchaining to propose a new effect set."""

    def get_successors(self,
                       effect_sets: _EffectSets) -> Iterator[_EffectSets]:
        operators = self._effect_sets_to_operators(effect_sets)
        import ipdb
        ipdb.set_trace()


class _EffectSearchHeuristic(abc.ABC):
    """Given a set of effect sets, produce a score, with lower better."""

    def __init__(
        self, trajectories: List[LowLevelTrajectory],
        predicates: Set[Predicate],
        effect_sets_to_operators: Callable[[_EffectSets], Set[STRIPSOperator]]
    ) -> None:
        self._trajectories = trajectories
        self._predicates = predicates
        self._effect_sets_to_operators = effect_sets_to_operators

    @abc.abstractmethod
    def __call__(self, effect_sets: _EffectSets) -> float:
        """Compute the heuristic value for the given effect sets."""
        raise NotImplementedError("Override me!")


class _BackChainingHeuristic(_EffectSearchHeuristic):
    """Counts the number of segments that are not yet covered by some operator
    in the backchaining sense."""

    def __call__(self, effect_sets: _EffectSets) -> float:
        operators = self._effect_sets_to_operators(effect_sets)
        import ipdb
        ipdb.set_trace()


class EffectSearchSTRIPSLearner(BaseSTRIPSLearner):
    """Base class for a effect search STRIPS learner."""

    @classmethod
    def get_name(cls) -> str:
        return "effect_search"

    def _learn(self) -> List[PartialNSRTAndDatastore]:

        # Set up hill-climbing search over effect sets.
        _S: TypeAlias = _EffectSets
        # An "action" here is a search operator and an integer representing the
        # count of successors generated by that operator.
        _A: TypeAlias = Tuple[_EffectSearchOperator, int]

        # Create the search operators.
        search_operators = self._create_search_operators()

        # Create the heuristic.
        heuristic = self._create_heuristic()

        # Initialize the search.
        initial_state = self._create_initial_effect_sets()

        def get_successors(effs: _S) -> Iterator[Tuple[_A, _S, float]]:
            for op in search_operators:
                for i, child in enumerate(op.get_successors(effs)):
                    yield (op, i), child, 1.0  # cost always 1

        # Run hill-climbing search.
        path, _, _ = utils.run_hill_climbing(initial_state=initial_state,
                                             check_goal=lambda _: False,
                                             get_successors=get_successors,
                                             heuristic=heuristic)

        # Extract the best effect set.
        best_effect_sets = path[-1]

        # Convert into operators.
        import ipdb
        ipdb.set_trace()

    def _create_search_operators(self) -> List[_EffectSearchOperator]:
        backchaining_op = _BackChainingEffectSearchOperator(
            self._trajectories, self._predicates,
            self._effect_sets_to_operators)
        return [backchaining_op]

    def _create_heuristic(self) -> _EffectSearchHeuristic:
        backchaining_heur = _BackChainingHeuristic(
            self._trajectories, self._predicates,
            self._effect_sets_to_operators)
        return backchaining_heur

    def _create_initial_effect_sets(self) -> _EffectSets:
        param_option_to_groups = {}
        param_options = [
            s.get_option().parent for segs in self._segmented_trajs
            for s in segs
        ]
        for param_option in param_options:
            option_vars = utils.create_new_variables(param_option.types)
            option_spec = (param_option, option_vars)
            add_effects = set()
            group = (option_spec, add_effects)
            param_option_to_groups[param_option] = [group]
        return _EffectSets(param_option_to_groups)

    @functools.lru_cache(maxsize=None)
    def _effect_sets_to_operators(
            self, effect_sets: _EffectSets) -> Set[STRIPSOperator]:
        pnads = self._effect_sets_to_pnads(effect_sets)
        # Add preconditions.
        for pnad in pnads:
            # If the PNAD is empty, that means we haven't yet computed good
            # effects, so none of the data is matching this PNAD. Just skip
            # in this case and wait for the search to find better effects.
            if not pnad.datastore:
                continue
            preconditions = self._induce_preconditions_via_intersection(pnad)
            pnad.op = pnad.op.copy_with(preconditions=preconditions)
        # Add delete and ignore effects.
        for pnad in pnads:
            self._compute_pnad_delete_effects(pnad)
            self._compute_pnad_ignore_effects(pnad)

        # TODO: handle keep effects in the outer search or here?

        # Extract operators.
        return [pnad.op for op in pnads]

    @functools.lru_cache(maxsize=None)
    def _effect_sets_to_pnads(
            self, effect_sets: _EffectSets) -> Set[PartialNSRTAndDatastore]:
        pnads = []
        for (option_spec, add_effects) in effect_sets:
            parameterized_option, parameters = option_spec
            op = STRIPSOperator(parameterized_option.name, parameters, set(),
                                add_effects, set(), set())
            pnad = PartialNSRTAndDatastore(op, [], option_spec)
            pnads.append(pnad)
        self._recompute_datastores_from_segments(pnads)
        return pnads
