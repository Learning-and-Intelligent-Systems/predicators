"""Learn operators by searching over sets of add effect sets."""

import abc
from dataclasses import dataclass
import functools
from typing import Callable, Dict, List, Set, Iterator, Tuple

from predicators import utils
from predicators.nsrt_learning.strips_learning import BaseSTRIPSLearner
from predicators.settings import CFG
from predicators.structs import ParameterizedOption, PartialNSRTAndDatastore, \
    Segment, STRIPSOperator, LiftedAtom, LowLevelTrajectory, Predicate, OptionSpec



@dataclass(frozen=True)
class _EffectSets:
    # Maps a parameterized option to a set of option specs (for that option)
    # and add effects.
    _param_option_to_group: Dict[ParameterizedOption, List[Tuple[OptionSpec, Set[LiftedAtom]]]]

    @functools.cached_property
    def _hash(self) -> int:
        option_to_hashable_group = {o: (tuple(v), frozenset(a))
                                    for o in self._param_option_to_group
                                    for ((_, v), a) in self._param_option_to_group[o]}
        return hash(tuple(option_to_hashable_group))

    def __hash__(self) -> int:
        return self._hash

    def __iter__(self) -> Iterator[Tuple[OptionSpec, Set[LiftedAtom]]]:
        for o in sorted(self._param_option_to_group):
            for (spec, atoms) in self._param_option_to_group[o]:
                yield (spec, atoms)


class _EffectSearchOperator(abc.ABC):
    """An operator that proposes successor sets of effect sets."""

    def __init__(self, trajectories: List[LowLevelTrajectory], predicates: Set[Predicate],
                 effect_sets_to_operators: Callable[[_EffectSets], Set[STRIPSOperator]]) -> None:
        self._trajectories = trajectories
        self._predicates = predicates
        self._effect_sets_to_operators = effect_sets_to_operators

    @abc.abstractmethod
    def get_successors(self, effect_sets: _EffectSets) -> Iterator[_EffectSets]:
        """Generate zero or more successor effect sets."""
        raise NotImplementedError("Override me!")


class _BackChainingEffectSearchOperator(_EffectSearchOperator):
    """An operator that uses backchaining to propose a new effect set."""

    def get_successors(self, effect_sets: _EffectSets) -> Iterator[_EffectSets]:
        operators = self._effect_sets_to_operators(effect_sets)
        import ipdb; ipdb.set_trace()


class _EffectSearchHeuristic(abc.ABC):
    """Given a set of effect sets, produce a score, with lower better."""

    def __init__(self, trajectories: List[LowLevelTrajectory], predicates: Set[Predicate],
                 effect_sets_to_operators: Callable[[_EffectSets], Set[STRIPSOperator]]) -> None:
        self._trajectories = trajectories
        self._predicates = predicates
        self._effect_sets_to_operators = effect_sets_to_operators

    @abc.abstractmethod
    def __call__(self, effect_sets: _EffectSets) -> float:
        """Compute the heuristic value for the given effect sets."""
        raise NotImplementedError("Override me!")


class _BackChainingHeuristic(_EffectSearchHeuristic):
    """Counts the number of segments that are not yet covered by some operator
    in the backchaining sense."""

    def __call__(self, effect_sets: _EffectSets) -> float:
        operators = self._effect_sets_to_operators(effect_sets)
        import ipdb; ipdb.set_trace()


class EffectSearchSTRIPSLearner(BaseSTRIPSLearner):
    """Base class for a effect search STRIPS learner."""

    @classmethod
    def get_name(cls) -> str:
        return "effect_search"

    def _learn(self) -> List[PartialNSRTAndDatastore]:

        # Set up hill-climbing search over effect sets.
        _S: TypeAlias = _EffectSets
        # An "action" here is a search operator and an integer representing the
        # count of successors generated by that operator.
        _A: TypeAlias = Tuple[_EffectSearchOperator, int]

        # Create the PG3 search operators.
        search_operators = self._create_search_operators()

        # The heuristic is what distinguishes PG3 from baseline approaches.
        heuristic = self._create_heuristic()

        # Initialize the search.
        param_options = [s.get_option().parent for segs in self._segmented_trajs for s in segs]
        initial_state = _EffectSets({o: {} for o in param_options})

        def get_successors(effs: _S) -> Iterator[Tuple[_A, _S, float]]:
            for op in search_operators:
                for i, child in enumerate(op.get_successors(effs)):
                    yield (op, i), child, 1.0  # cost always 1

        # Run hill-climbing search.
        path, _, _ = utils.run_hill_climbing(
            initial_state=initial_state,
            check_goal=lambda _: False,
            get_successors=get_successors,
            heuristic=heuristic)

        # Extract the best effect set.
        best_effect_sets = path[-1]

        # Convert into operators.
        import ipdb; ipdb.set_trace()

    def _create_search_operators(self) -> List[_EffectSearchOperator]:
        backchaining_op = _BackChainingEffectSearchOperator(self._trajectories, self._predicates, self._effect_sets_to_operators)
        return [backchaining_op]

    def _create_heuristic(self) -> _EffectSearchHeuristic:
        backchaining_heur = _BackChainingHeuristic(self._trajectories, self._predicates, self._effect_sets_to_operators)
        return backchaining_heur

    @functools.lru_cache(maxsize=None)
    def _effect_sets_to_operators(self, effect_sets: _EffectSets) -> Set[STRIPSOperator]:
        pnads = self._effect_sets_to_pnads(effect_sets)
        import ipdb; ipdb.set_trace()

    @functools.lru_cache(maxsize=None)
    def _effect_sets_to_pnads(self, effect_sets: _EffectSets) -> Set[PartialNSRTAndDatastore]:
        pnads = []
        for (option_spec, add_effects) in effect_sets:
            parameterized_option, parameters = option_spec
            op = STRIPSOperator(parameterized_option.name, parameters, set(),
                                add_effects, set(), set())
            pnad = PartialNSRTAndDatastore(op, [], option_spec)
            pnads.append(pnad)
        self._recompute_datastores_from_segments(pnads)
        return pnads
        
